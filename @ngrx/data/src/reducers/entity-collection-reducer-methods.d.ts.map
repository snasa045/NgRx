{"version":3,"file":"entity-collection-reducer-methods.d.ts","sources":["entity-collection-reducer-methods.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { EntityAdapter, IdSelector, Update } from '@ngrx/entity';\nimport { ChangeStateMap, EntityCollection } from './entity-collection';\nimport { EntityAction } from '../actions/entity-action';\nimport { EntityActionDataServiceError } from '../dataservices/data-service-error';\nimport { EntityActionGuard } from '../actions/entity-action-guard';\nimport { EntityChangeTracker } from './entity-change-tracker';\nimport { EntityDefinition } from '../entity-metadata/entity-definition';\nimport { EntityDefinitionService } from '../entity-metadata/entity-definition.service';\nimport { MergeStrategy } from '../actions/merge-strategy';\nimport { UpdateResponseData } from '../actions/update-response-data';\n/**\n * Map of {EntityOp} to reducer method for the operation.\n * If an operation is missing, caller should return the collection for that reducer.\n */\nexport interface EntityCollectionReducerMethodMap<T> {\n    [method: string]: (collection: EntityCollection<T>, action: EntityAction) => EntityCollection<T>;\n}\n/**\n * Base implementation of reducer methods for an entity collection.\n */\nexport declare class EntityCollectionReducerMethods<T> {\n    entityName: string;\n    definition: EntityDefinition<T>;\n    protected adapter: EntityAdapter<T>;\n    protected guard: EntityActionGuard<T>;\n    /** True if this collection tracks unsaved changes */\n    protected isChangeTracking: boolean;\n    /** Extract the primary key (id); default to `id` */\n    selectId: IdSelector<T>;\n    /**\n     * Track changes to entities since the last query or save\n     * Can revert some or all of those changes\n     */\n    entityChangeTracker: EntityChangeTracker<T>;\n    /**\n     * Convert an entity (or partial entity) into the `Update<T>` object\n     * `id`: the primary key and\n     * `changes`: the entity (or partial entity of changes).\n     */\n    protected toUpdate: (entity: Partial<T>) => Update<T>;\n    /**\n     * Dictionary of the {EntityCollectionReducerMethods} for this entity type,\n     * keyed by the {EntityOp}\n     */\n    readonly methods: EntityCollectionReducerMethodMap<T>;\n    constructor(entityName: string, definition: EntityDefinition<T>, entityChangeTracker?: EntityChangeTracker<T>);\n    /** Cancel a persistence operation */\n    protected cancelPersist(collection: EntityCollection<T>): EntityCollection<T>;\n    protected queryAll(collection: EntityCollection<T>): EntityCollection<T>;\n    protected queryAllError(collection: EntityCollection<T>, action: EntityAction<EntityActionDataServiceError>): EntityCollection<T>;\n    /**\n     * Merges query results per the MergeStrategy\n     * Sets loading flag to false and loaded flag to true.\n     */\n    protected queryAllSuccess(collection: EntityCollection<T>, action: EntityAction<T[]>): EntityCollection<T>;\n    protected queryByKey(collection: EntityCollection<T>, action: EntityAction<number | string>): EntityCollection<T>;\n    protected queryByKeyError(collection: EntityCollection<T>, action: EntityAction<EntityActionDataServiceError>): EntityCollection<T>;\n    protected queryByKeySuccess(collection: EntityCollection<T>, action: EntityAction<T>): EntityCollection<T>;\n    protected queryLoad(collection: EntityCollection<T>): EntityCollection<T>;\n    protected queryLoadError(collection: EntityCollection<T>, action: EntityAction<EntityActionDataServiceError>): EntityCollection<T>;\n    /**\n     * Replaces all entities in the collection\n     * Sets loaded flag to true, loading flag to false,\n     * and clears changeState for the entire collection.\n     */\n    protected queryLoadSuccess(collection: EntityCollection<T>, action: EntityAction<T[]>): EntityCollection<T>;\n    protected queryMany(collection: EntityCollection<T>, action: EntityAction): EntityCollection<T>;\n    protected queryManyError(collection: EntityCollection<T>, action: EntityAction<EntityActionDataServiceError>): EntityCollection<T>;\n    protected queryManySuccess(collection: EntityCollection<T>, action: EntityAction<T[]>): EntityCollection<T>;\n    /**\n     * Save multiple new entities.\n     * If saving pessimistically, delay adding to collection until server acknowledges success.\n     * If saving optimistically; add immediately.\n     * @param collection The collection to which the entities should be added.\n     * @param action The action payload holds options, including whether the save is optimistic,\n     * and the data, which must be an array of entities.\n     * If saving optimistically, the entities must have their keys.\n     */\n    protected saveAddMany(collection: EntityCollection<T>, action: EntityAction<T[]>): EntityCollection<T>;\n    /**\n     * Attempt to save new entities failed or timed-out.\n     * Action holds the error.\n     * If saved pessimistically, new entities are not in the collection and\n     * you may not have to compensate for the error.\n     * If saved optimistically, the unsaved entities are in the collection and\n     * you may need to compensate for the error.\n     */\n    protected saveAddManyError(collection: EntityCollection<T>, action: EntityAction<EntityActionDataServiceError>): EntityCollection<T>;\n    /**\n     * Successfully saved new entities to the server.\n     * If saved pessimistically, add the entities from the server to the collection.\n     * If saved optimistically, the added entities are already in the collection.\n     * However, the server might have set or modified other fields (e.g, concurrency field),\n     * and may even return additional new entities.\n     * Therefore, upsert the entities in the collection with the returned values (if any)\n     * Caution: in a race, this update could overwrite unsaved user changes.\n     * Use pessimistic add to avoid this risk.\n     * Note: saveAddManySuccess differs from saveAddOneSuccess when optimistic.\n     * saveAddOneSuccess updates (not upserts) with the lone entity from the server.\n     * There is no effect if the entity is not already in cache.\n     * saveAddManySuccess will add an entity if it is not found in cache.\n     */\n    protected saveAddManySuccess(collection: EntityCollection<T>, action: EntityAction<T[]>): EntityCollection<T>;\n    /**\n     * Save a new entity.\n     * If saving pessimistically, delay adding to collection until server acknowledges success.\n     * If saving optimistically; add entity immediately.\n     * @param collection The collection to which the entity should be added.\n     * @param action The action payload holds options, including whether the save is optimistic,\n     * and the data, which must be an entity.\n     * If saving optimistically, the entity must have a key.\n     */\n    protected saveAddOne(collection: EntityCollection<T>, action: EntityAction<T>): EntityCollection<T>;\n    /**\n     * Attempt to save a new entity failed or timed-out.\n     * Action holds the error.\n     * If saved pessimistically, the entity is not in the collection and\n     * you may not have to compensate for the error.\n     * If saved optimistically, the unsaved entity is in the collection and\n     * you may need to compensate for the error.\n     */\n    protected saveAddOneError(collection: EntityCollection<T>, action: EntityAction<EntityActionDataServiceError>): EntityCollection<T>;\n    /**\n     * Successfully saved a new entity to the server.\n     * If saved pessimistically, add the entity from the server to the collection.\n     * If saved optimistically, the added entity is already in the collection.\n     * However, the server might have set or modified other fields (e.g, concurrency field)\n     * Therefore, update the entity in the collection with the returned value (if any)\n     * Caution: in a race, this update could overwrite unsaved user changes.\n     * Use pessimistic add to avoid this risk.\n     */\n    protected saveAddOneSuccess(collection: EntityCollection<T>, action: EntityAction<T>): EntityCollection<T>;\n    /**\n     * Delete an entity from the server by key and remove it from the collection (if present).\n     * If the entity is an unsaved new entity, remove it from the collection immediately\n     * and skip the server delete request.\n     * An optimistic save removes an existing entity from the collection immediately;\n     * a pessimistic save removes it after the server confirms successful delete.\n     * @param collection Will remove the entity with this key from the collection.\n     * @param action The action payload holds options, including whether the save is optimistic,\n     * and the data, which must be a primary key or an entity with a key;\n     * this reducer extracts the key from the entity.\n     */\n    protected saveDeleteOne(collection: EntityCollection<T>, action: EntityAction<number | string | T>): EntityCollection<T>;\n    /**\n     * Attempt to delete the entity on the server failed or timed-out.\n     * Action holds the error.\n     * If saved pessimistically, the entity could still be in the collection and\n     * you may not have to compensate for the error.\n     * If saved optimistically, the entity is not in the collection and\n     * you may need to compensate for the error.\n     */\n    protected saveDeleteOneError(collection: EntityCollection<T>, action: EntityAction<EntityActionDataServiceError>): EntityCollection<T>;\n    /**\n     * Successfully deleted entity on the server. The key of the deleted entity is in the action payload data.\n     * If saved pessimistically, if the entity is still in the collection it will be removed.\n     * If saved optimistically, the entity has already been removed from the collection.\n     */\n    protected saveDeleteOneSuccess(collection: EntityCollection<T>, action: EntityAction<number | string>): EntityCollection<T>;\n    /**\n     * Delete multiple entities from the server by key and remove them from the collection (if present).\n     * Removes unsaved new entities from the collection immediately\n     * but the id is still sent to the server for deletion even though the server will not find that entity.\n     * Therefore, the server must be willing to ignore a delete request for an entity it cannot find.\n     * An optimistic save removes existing entities from the collection immediately;\n     * a pessimistic save removes them after the server confirms successful delete.\n     * @param collection Removes entities from this collection.\n     * @param action The action payload holds options, including whether the save is optimistic,\n     * and the data, which must be an array of primary keys or entities with a key;\n     * this reducer extracts the key from the entity.\n     */\n    protected saveDeleteMany(collection: EntityCollection<T>, action: EntityAction<(number | string | T)[]>): EntityCollection<T>;\n    /**\n     * Attempt to delete the entities on the server failed or timed-out.\n     * Action holds the error.\n     * If saved pessimistically, the entities could still be in the collection and\n     * you may not have to compensate for the error.\n     * If saved optimistically, the entities are not in the collection and\n     * you may need to compensate for the error.\n     */\n    protected saveDeleteManyError(collection: EntityCollection<T>, action: EntityAction<EntityActionDataServiceError>): EntityCollection<T>;\n    /**\n     * Successfully deleted entities on the server. The keys of the deleted entities are in the action payload data.\n     * If saved pessimistically, entities that are still in the collection will be removed.\n     * If saved optimistically, the entities have already been removed from the collection.\n     */\n    protected saveDeleteManySuccess(collection: EntityCollection<T>, action: EntityAction<(number | string)[]>): EntityCollection<T>;\n    /**\n     * Save an update to an existing entity.\n     * If saving pessimistically, update the entity in the collection after the server confirms success.\n     * If saving optimistically, update the entity immediately, before the save request.\n     * @param collection The collection to update\n     * @param action The action payload holds options, including if the save is optimistic,\n     * and the data which, must be an {Update<T>}\n     */\n    protected saveUpdateOne(collection: EntityCollection<T>, action: EntityAction<Update<T>>): EntityCollection<T>;\n    /**\n     * Attempt to update the entity on the server failed or timed-out.\n     * Action holds the error.\n     * If saved pessimistically, the entity in the collection is in the pre-save state\n     * you may not have to compensate for the error.\n     * If saved optimistically, the entity in the collection was updated\n     * and you may need to compensate for the error.\n     */\n    protected saveUpdateOneError(collection: EntityCollection<T>, action: EntityAction<EntityActionDataServiceError>): EntityCollection<T>;\n    /**\n     * Successfully saved the updated entity to the server.\n     * If saved pessimistically, update the entity in the collection with data from the server.\n     * If saved optimistically, the entity was already updated in the collection.\n     * However, the server might have set or modified other fields (e.g, concurrency field)\n     * Therefore, update the entity in the collection with the returned value (if any)\n     * Caution: in a race, this update could overwrite unsaved user changes.\n     * Use pessimistic update to avoid this risk.\n     * @param collection The collection to update\n     * @param action The action payload holds options, including if the save is optimistic, and\n     * the update data which, must be an UpdateResponse<T> that corresponds to the Update sent to the server.\n     * You must include an UpdateResponse even if the save was optimistic,\n     * to ensure that the change tracking is properly reset.\n     */\n    protected saveUpdateOneSuccess(collection: EntityCollection<T>, action: EntityAction<UpdateResponseData<T>>): EntityCollection<T>;\n    /**\n     * Save updated entities.\n     * If saving pessimistically, update the entities in the collection after the server confirms success.\n     * If saving optimistically, update the entities immediately, before the save request.\n     * @param collection The collection to update\n     * @param action The action payload holds options, including if the save is optimistic,\n     * and the data which, must be an array of {Update<T>}.\n     */\n    protected saveUpdateMany(collection: EntityCollection<T>, action: EntityAction<Update<T>[]>): EntityCollection<T>;\n    /**\n     * Attempt to update entities on the server failed or timed-out.\n     * Action holds the error.\n     * If saved pessimistically, the entities in the collection are in the pre-save state\n     * you may not have to compensate for the error.\n     * If saved optimistically, the entities in the collection were updated\n     * and you may need to compensate for the error.\n     */\n    protected saveUpdateManyError(collection: EntityCollection<T>, action: EntityAction<EntityActionDataServiceError>): EntityCollection<T>;\n    /**\n     * Successfully saved the updated entities to the server.\n     * If saved pessimistically, the entities in the collection will be updated with data from the server.\n     * If saved optimistically, the entities in the collection were already updated.\n     * However, the server might have set or modified other fields (e.g, concurrency field)\n     * Therefore, update the entity in the collection with the returned values (if any)\n     * Caution: in a race, this update could overwrite unsaved user changes.\n     * Use pessimistic update to avoid this risk.\n     * @param collection The collection to update\n     * @param action The action payload holds options, including if the save is optimistic,\n     * and the data which, must be an array of UpdateResponse<T>.\n     * You must include an UpdateResponse for every Update sent to the server,\n     * even if the save was optimistic, to ensure that the change tracking is properly reset.\n     */\n    protected saveUpdateManySuccess(collection: EntityCollection<T>, action: EntityAction<UpdateResponseData<T>[]>): EntityCollection<T>;\n    /**\n     * Save a new or existing entity.\n     * If saving pessimistically, delay adding to collection until server acknowledges success.\n     * If saving optimistically; add immediately.\n     * @param collection The collection to which the entity should be upserted.\n     * @param action The action payload holds options, including whether the save is optimistic,\n     * and the data, which must be a whole entity.\n     * If saving optimistically, the entity must have its key.\n     */\n    protected saveUpsertOne(collection: EntityCollection<T>, action: EntityAction<T>): EntityCollection<T>;\n    /**\n     * Attempt to save new or existing entity failed or timed-out.\n     * Action holds the error.\n     * If saved pessimistically, new or updated entity is not in the collection and\n     * you may not have to compensate for the error.\n     * If saved optimistically, the unsaved entities are in the collection and\n     * you may need to compensate for the error.\n     */\n    protected saveUpsertOneError(collection: EntityCollection<T>, action: EntityAction<EntityActionDataServiceError>): EntityCollection<T>;\n    /**\n     * Successfully saved new or existing entities to the server.\n     * If saved pessimistically, add the entities from the server to the collection.\n     * If saved optimistically, the added entities are already in the collection.\n     * However, the server might have set or modified other fields (e.g, concurrency field)\n     * Therefore, update the entities in the collection with the returned values (if any)\n     * Caution: in a race, this update could overwrite unsaved user changes.\n     * Use pessimistic add to avoid this risk.\n     */\n    protected saveUpsertOneSuccess(collection: EntityCollection<T>, action: EntityAction<T>): EntityCollection<T>;\n    /**\n     * Save multiple new or existing entities.\n     * If saving pessimistically, delay adding to collection until server acknowledges success.\n     * If saving optimistically; add immediately.\n     * @param collection The collection to which the entities should be upserted.\n     * @param action The action payload holds options, including whether the save is optimistic,\n     * and the data, which must be an array of whole entities.\n     * If saving optimistically, the entities must have their keys.\n     */\n    protected saveUpsertMany(collection: EntityCollection<T>, action: EntityAction<T[]>): EntityCollection<T>;\n    /**\n     * Attempt to save new or existing entities failed or timed-out.\n     * Action holds the error.\n     * If saved pessimistically, new entities are not in the collection and\n     * you may not have to compensate for the error.\n     * If saved optimistically, the unsaved entities are in the collection and\n     * you may need to compensate for the error.\n     */\n    protected saveUpsertManyError(collection: EntityCollection<T>, action: EntityAction<EntityActionDataServiceError>): EntityCollection<T>;\n    /**\n     * Successfully saved new or existing entities to the server.\n     * If saved pessimistically, add the entities from the server to the collection.\n     * If saved optimistically, the added entities are already in the collection.\n     * However, the server might have set or modified other fields (e.g, concurrency field)\n     * Therefore, update the entities in the collection with the returned values (if any)\n     * Caution: in a race, this update could overwrite unsaved user changes.\n     * Use pessimistic add to avoid this risk.\n     */\n    protected saveUpsertManySuccess(collection: EntityCollection<T>, action: EntityAction<T[]>): EntityCollection<T>;\n    /**\n     * Replaces all entities in the collection\n     * Sets loaded flag to true.\n     * Merges query results, preserving unsaved changes\n     */\n    protected addAll(collection: EntityCollection<T>, action: EntityAction<T[]>): EntityCollection<T>;\n    protected addMany(collection: EntityCollection<T>, action: EntityAction<T[]>): EntityCollection<T>;\n    protected addOne(collection: EntityCollection<T>, action: EntityAction<T>): EntityCollection<T>;\n    protected removeMany(collection: EntityCollection<T>, action: EntityAction<number[] | string[]>): EntityCollection<T>;\n    protected removeOne(collection: EntityCollection<T>, action: EntityAction<number | string>): EntityCollection<T>;\n    protected removeAll(collection: EntityCollection<T>, action: EntityAction<T>): EntityCollection<T>;\n    protected updateMany(collection: EntityCollection<T>, action: EntityAction<Update<T>[]>): EntityCollection<T>;\n    protected updateOne(collection: EntityCollection<T>, action: EntityAction<Update<T>>): EntityCollection<T>;\n    protected upsertMany(collection: EntityCollection<T>, action: EntityAction<T[]>): EntityCollection<T>;\n    protected upsertOne(collection: EntityCollection<T>, action: EntityAction<T>): EntityCollection<T>;\n    protected commitAll(collection: EntityCollection<T>): EntityCollection<T>;\n    protected commitMany(collection: EntityCollection<T>, action: EntityAction<T[]>): EntityCollection<T>;\n    protected commitOne(collection: EntityCollection<T>, action: EntityAction<T>): EntityCollection<T>;\n    protected undoAll(collection: EntityCollection<T>): EntityCollection<T>;\n    protected undoMany(collection: EntityCollection<T>, action: EntityAction<T[]>): EntityCollection<T>;\n    protected undoOne(collection: EntityCollection<T>, action: EntityAction<T>): EntityCollection<T>;\n    /** Dangerous: Completely replace the collection's ChangeState. Use rarely and wisely. */\n    protected setChangeState(collection: EntityCollection<T>, action: EntityAction<ChangeStateMap<T>>): EntityCollection<T>;\n    /**\n     * Dangerous: Completely replace the collection.\n     * Primarily for testing and rehydration from local storage.\n     * Use rarely and wisely.\n     */\n    protected setCollection(collection: EntityCollection<T>, action: EntityAction<EntityCollection<T>>): EntityCollection<T>;\n    protected setFilter(collection: EntityCollection<T>, action: EntityAction<any>): EntityCollection<T>;\n    protected setLoaded(collection: EntityCollection<T>, action: EntityAction<boolean>): EntityCollection<T>;\n    protected setLoading(collection: EntityCollection<T>, action: EntityAction<boolean>): EntityCollection<T>;\n    protected setLoadingFalse(collection: EntityCollection<T>): EntityCollection<T>;\n    protected setLoadingTrue(collection: EntityCollection<T>): EntityCollection<T>;\n    /** Set the collection's loading flag */\n    protected setLoadingFlag(collection: EntityCollection<T>, loading: boolean): EntityCollection<T>;\n    /** Safely extract data from the EntityAction payload */\n    protected extractData<D = any>(action: EntityAction<D>): D;\n    /** Safely extract MergeStrategy from EntityAction. Set to IgnoreChanges if collection itself is not tracked. */\n    protected extractMergeStrategy(action: EntityAction): MergeStrategy | undefined;\n    protected isOptimistic(action: EntityAction): boolean;\n}\n/**\n * Creates {EntityCollectionReducerMethods} for a given entity type.\n */\nexport declare class EntityCollectionReducerMethodsFactory {\n    private entityDefinitionService;\n    constructor(entityDefinitionService: EntityDefinitionService);\n    /** Create the  {EntityCollectionReducerMethods} for the named entity type */\n    create<T>(entityName: string): EntityCollectionReducerMethodMap<T>;\n}\n"]}